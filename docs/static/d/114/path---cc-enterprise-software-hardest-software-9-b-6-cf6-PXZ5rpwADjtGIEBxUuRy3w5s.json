{"pageContext":{"id":"601814","parent":"__SOURCE__","slug":"enterprise-software-hardest-software","internal":{"contentDigest":"a393af573eb30be230dfad622955e7a4","type":"ContentCoPost","owner":"default-site-plugin"},"children":[],"title":"Enterprise software is the hardest software to write. Period.","preview":{"source":"https://cdn.techinasia.com/wp-content/uploads/2018/11/john-schnobrich-520019-unsplash.jpg","attachment_meta":{"width":1000,"height":630,"sizes":{"thumbnail":{"width":100,"height":100,"url":"https://cdn.techinasia.com/wp-content/uploads/2018/11/john-schnobrich-520019-unsplash-100x100.jpg"},"medium":{"width":350,"height":221,"url":"https://cdn.techinasia.com/wp-content/uploads/2018/11/john-schnobrich-520019-unsplash-350x221.jpg"},"large":{"width":750,"height":473,"url":"https://cdn.techinasia.com/wp-content/uploads/2018/11/john-schnobrich-520019-unsplash-750x473.jpg"}}}},"createdAt":"2018-11-26T07:00:33","content":"<p id=\"d9bc\" class=\"graf graf--p graf-after--h3\">There is a perception that building enterprise software is easy.</p>\n<p>I’ve worked for an aerospace company, I’ve worked on computer simulations and mathematical optimizations, I’ve built computer language parsers, written device drivers, etc. Without hesitation, I would say that working on enterprise software is the hardest.</p>\n<p id=\"3e90\" class=\"graf graf--p graf-after--p\">Why? To examine this, we can divide software into four different types (these are rough categorizations, as software is hard to pin down):</p>\n<ol class=\"postList\">\n<li id=\"5a00\" class=\"graf graf--li graf-after--p\">\n<strong class=\"markup--strong markup--li-strong\">Scientific and engineering software: </strong>This covers aerospace programming, process control systems in power plants and electrical grids, and engineering analysis to design bridges, buildings, and dams. I’m also throwing AI, robotics, 3D printing, and voice processing in here as well.</li>\n<li id=\"d4a3\" class=\"graf graf--li graf-after--li\">\n<strong class=\"markup--strong markup--li-strong\">Packaged software: </strong>The most prominent example of packaged software is Microsoft’s Office suite. This category also includes graphic art programs such as Adobe Illustrator and Photoshop. It includes business software like QuickBooks and a myriad of other programs that are purchased in some manner by users.</li>\n<li id=\"b7bf\" class=\"graf graf--li graf-after--li\">\n<strong class=\"markup--strong markup--li-strong\">Cloud software: </strong>This software works in a browser. Basically, we’re talking about HTTP requests that result in bundles of HTML, CSS, and Javascript being sent to the browser. The software is a combination of the Javascript on the browser and the back-end code that runs on the server.</li>\n<li id=\"0e86\" class=\"graf graf--li graf-after--li\">\n<strong class=\"markup--strong markup--li-strong\">Enterprise systems: </strong>Enterprise systems are software that are integrated into the operations of an organization. The most common ones handle general ledger, financials, payables, and receivables.</li>\n</ol>\n<h2 id=\"3292\" class=\"graf graf--p graf-after--li\">\n<strong class=\"markup--strong markup--p-strong\">Why is enterprise so much harder than the other three</strong><em class=\"markup--em markup--p-em\">?</em>\n</h2>\n<p id=\"4c8d\" class=\"graf graf--p graf-after--p\">There are three factors that greatly influence how difficult it is to develop software:</p>\n<ol>\n<li>\n<strong class=\"markup--strong markup--li-strong\">Control over features: </strong>Does the project team have the final say when it comes to features and changes? Do they have to consult with an outside constituency?</li>\n<li id=\"463d\" class=\"graf graf--p graf-after--p\">\n<strong class=\"markup--strong markup--p-strong\">Generic or constant test data: </strong>How do you generate test data? Is there a lot of existing test data or do you have to try to construct it? If you have to construct it, how much coverage do you generate?</li>\n<li id=\"a2ee\" class=\"graf graf--p graf-after--p\">\n<strong><span class=\"markup--strong markup--p-strong\">C</span></strong><strong class=\"markup--strong markup--p-strong\">hange over time: </strong>Does the software have to change its logic over time, yet still preserve existing information? And are there changes during development?</li>\n</ol>\n<p id=\"11b5\" class=\"graf graf--p graf-after--p\">Let’s examine each type of software with respect to these features.</p>\n<h2 id=\"84ce\" class=\"graf graf--h4 graf-after--p\">Scientific and engineering software</h2>\n<p id=\"6f49\" class=\"graf graf--p graf-after--h4\">When I wrote software for a radar imaging system, I could take some archived satellite data, run my software, and look at the results, continuing until it gave me seemingly correct answers. Then, I could process the image and check the fidelity.</p>\n<p id=\"492c\" class=\"graf graf--p graf-after--p\">It was totally repeatable and predictable.</p>\n<p id=\"cc4c\" class=\"graf graf--p graf-after--p\">Testing was also straightforward: I could grab any part of the satellite data and image it. Analyzing the image indicated how accuracy in antenna positioning improved the resolution of the image. This meant that there was a massive amount of data that I could use for testing.</p>\n<p id=\"8dad\" class=\"graf graf--p graf-after--p\">In technical/engineering software, decisions on changes almost always rest with the project team, with very little input from external sources.</p>\n<p>Finally, these kinds of software are also used for a single case at a time, for one particular situation. If it needs to be modified, a new model is produced.</p>\n<p id=\"8268\" class=\"graf graf--p graf-after--li\">All of this makes scientific/engineering systems less difficult than they might seem on the surface.</p>\n<h2 id=\"b4b7\" class=\"graf graf--h4 graf-after--p\">Packaged software</h2>\n<p id=\"f237\" class=\"graf graf--p graf-after--h4\">In the 1990s, I was an owner/partner of Paradigm Development Corporation, a contract-software house that did a lot of work for Microsoft, among other software companies. One project we had was to remove unused lines in the Microsoft Word code base, which was high entropy (aka a code base that has large technical debt).</p>\n<p id=\"5a06\" class=\"graf graf--p graf-after--p\">You may be thinking, “But Microsoft Word works well.” That’s true. It’s stable and gets the job done without a massive amount of computer errors. So, how does a high-entropy code base result in a stable product?</p>\n<p id=\"2951\" class=\"graf graf--p graf-after--p\">It’s all about testing. Microsoft has a huge QA team which is relentless in testing. This doesn’t necessarily mean they have reduced the entropy of the code. But by testing and making sure that all the bugs are inconsequential or manageable, the company can produce a version suitable for release.</p>\n<p>But there is something that makes testing package software easier.</p>\n<p id=\"3785\" class=\"graf graf--p graf-after--p\">Take testing word processing software, for example. It doesn’t matter what the actual words are. What matters for testing is how the software handles the general word processing characteristics of a document (very long words, paragraphs that take up more than a page, etc.). The actual text is immaterial. So, testing package software is not as hard as it could be.</p>\n<p id=\"ba19\" class=\"graf graf--p graf-after--p\">An office suite is a set of tools to be used by a lot of people. So, everything is general, and hence can be tested with a generalized test set.</p>\n<p id=\"a8c8\" class=\"graf graf--p graf-after--p\">The features of a package like Microsoft Word are also totally determined by the project team. Others may get involved, but the final say lies with the team.</p>\n<p>Finally, package software is shipped with a clear set of capabilities, which don’t change with the next release. This means that new features can be done in the time between releases. The data may not be compatible from one release to another, but there is no requirement to have new feature code work on both old and new data.</p>\n<h2 id=\"5ddc\" class=\"graf graf--h4 graf-after--li\">Cloud software</h2>\n<p id=\"d480\" class=\"graf graf--p graf-after--h4\">In this model of software delivery, the supplier runs servers that are accessible over the internet (“the cloud”), and clients run software, browsers, or apps on their local computers to display information on the screen and allow input.</p>\n<p id=\"3198\" class=\"graf graf--p graf-after--p\">Clearly, one of the characteristics of this model is that the software can be continually updated. However, the current approach to this is to develop MVPs.</p>\n<p id=\"7193\" class=\"graf graf--p graf-after--p\">All of the decisions about features are made by the project team. This is a centralized service that is trying to develop features that customers want, which means that features are driven by marketing reasons and certainly not by any outside group.</p>\n<p id=\"95a8\" class=\"graf graf--p graf-after--p\">If there are errors, they are fixed as quickly as possible, and the new code is put up on the website. Any client logging in after that will be using the new code. Because of this fast fix-and-deploy cycle, there is a tendency to use the clients as the QA department. Hence, testing is easier because there is not as much of it done.</p>\n<p class=\"graf graf--p graf-after--p\">But there is a requirement to keep a client’s old data operational despite the addition of new features. This eventually becomes a major problem down the road, but the hope is that when you get there, you will have enough money to solve them.</p>\n<p id=\"e15b\" class=\"graf graf--p graf-after--li\">This is probably the second hardest kind of software. It looks easy, but it can become really difficult when the client base grows very large.</p>\n<h2 id=\"631b\" class=\"graf graf--h4 graf-after--p\">Enterprise systems software</h2>\n<p id=\"a27b\" class=\"graf graf--p graf-after--p\">I once built a system for a large union. I wrote a design document, where I made clear what the system would and wouldn’t do. All the managers signed off on the design. But when the system became operational, one staff said there was one feature that was essential, which no one had thought to include.</p>\n<p id=\"b1cf\" class=\"graf graf--p graf-after--p\">I had no real choice; I had to add the feature. Clearly, I didn’t have total control.</p>\n<p id=\"d8c1\" class=\"graf graf--p graf-after--p\">The control over change rests mainly with the user base. The enterprise system has to allow people to do their jobs and process information.</p>\n<p id=\"63d3\" class=\"graf graf--p graf-after--p\">Then, there are changes. If a tax change is introduced by a level of government, the organization has no choice but to respond to it. If senior management mandates some organizational change, the system will have to respond.</p>\n<p id=\"32cd\" class=\"graf graf--p graf-after--p\">In a system such as payroll software, you have to have test cases that cover a good percentage of the possibilities. Let us suppose there are 20 different such payroll events that are possible for an employee. Each one is either off or on, so there are a lot of possibilities.</p>\n<p id=\"f46e\" class=\"graf graf--p graf-after--p\">If you don’t want to get drowned in this, you have to maintain strict independence among all of these factors. However, in practice, some of these possibilities are dependent on others, and the independence between these factors can be modified by changes too.</p>\n<p id=\"cb2c\" class=\"graf graf--p graf-after--p\">If this was an aerospace project, you could generate and test a million base combinations with random legal parameters. But for an enterprise system that is being built in the midst of continual change, you don’t have that kind of time and budget.</p>\n<p id=\"b8ef\" class=\"graf graf--p graf-after--p\">The only way is to do your testing in the guise of installation. All you can do is some simple testing, turn it loose in real life, and fix it when it goes wrong.</p>\n<p id=\"465a\" class=\"graf graf--p graf-after--p\">Let’s be honest here, this is what happens in the majority of cases.</p>\n<p id=\"038a\" class=\"graf graf--p graf-after--p\">You can see that in all the other software types, the objectives were specified. In enterprise computing, what is needed is much less clear.</p>\n<p id=\"5395\" class=\"graf graf--p graf-after--p\">So, what is being built is not totally clear, and the builders don’t have control over what is needed. On top of this, the business logic can change month to month.</p>\n<h2 id=\"50a0\" class=\"graf graf--h4 graf-after--li\">Summary</h2>\n<p id=\"eeca\" class=\"graf graf--p graf-after--h4\">In short, enterprise systems have some properties that other software simply don’t have.</p>\n<p id=\"2c3d\" class=\"graf graf--p graf-after--p\">As a programmer, it is much easier to work on other kinds of software. Trying to develop software while keeping it in sync with the activities of a changing organization is really, really hard.</p>\n<p id=\"fbeb\" class=\"graf graf--p graf-after--p\">If you don’t believe me, try it.</p>\n<p id=\"5f49\" class=\"graf graf--p graf-after--p\"><i>The full version of this article was first published on <a href=\"https://codeburst.io/enterprise-software-is-the-hardest-software-to-write-c76d59725f3\" target=\"_blank\" rel=\"nofollow noopener\">Medium</a>.</i></p>","categories":[{"id":"43226","name":"Community","slug":"community"},{"id":"7225","name":"Opinion","slug":"opinion-editorial"}],"author":{"name":"Lance Gutteridge","image":"https://cdn.techinasia.com/wp-content/authors/234869.jpg?v=1542282785"},"seo":{"title":"Enterprise software is the hardest software to write. Period.","description":"There is a perception that building enterprise software is easy. That is hardly the case.","image":"https://cdn.techinasia.com/wp-content/uploads/2018/11/john-schnobrich-520019-unsplash.jpg"}}}